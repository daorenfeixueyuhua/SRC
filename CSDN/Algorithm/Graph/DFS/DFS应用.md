# **DFS遍历n*m的地图**

## **1. 图**

```txt
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
```

@表示起点，'.' 表示可走，'#' 表示障碍，对该图进行遍历，并统计行走步数

## **2. 算法原理**

改图我们可以使用一个队列来保存准备访问的节点，初始将起点放入队中，对对头节点进行访问，访问时，探索其上下左右节点，满足未访问，不再队中，节点为'.'，将其放入队中，访问结束时，标记该节点，并将该节点中队中删除，再去访问对的头节点，直至对为空。

## **3. 代码实现（python）**

```python
# f = lambda:map(int, input().split())
# n, m = f()
#
# g = [''] * n
#
# for i in range(n):
#     g[i] = input()

n = 9
m = 11
v = [[0] * m for i in range(n)]
g = ['.#.........',
     '.#.#######.',
     '.#.#.....#.',
     '.#.#.###.#.',
     '.#.#..@#.#.',
     '.#.#####.#.',
     '.#.......#.',
     '.#########.',
     '...........']

# 找到起点
si, sj = 0, 0
for i in range(n):
    for j in range(m):
        if g[i][j] == '@':
            si = i
            sj = j
print(si, sj)

# 节点访问顺序
l = []


def bfs(i, j):
    c = 0
    # Q为重点
    Q = [(i, j)]
    while Q:
        c += 1
        i, j = Q[0]
        l.append((i, j))
        # print(g[i][j])
        # 对上下左右的点进行判断，将为访问、不再等待访问队列Q中、且值为 '.' 的节点，加入Q中
        if 0 < j and not v[i][j-1] and (i, j-1) not in Q and g[i][j-1] == '.':
            Q.append((i, j-1))
        if j < m-1 and not v[i][j+1] and (i, j+1) not in Q and g[i][j+1] == '.':
            Q.append((i, j+1))
        if 0 < i and not v[i-1][j] and (i-1, j) not in Q and g[i-1][j] == '.':
            Q.append((i-1, j))
        if i < n-1 and not v[i+1][j] and (i+1, j) not in Q and g[i+1][j] == '.':
            Q.append((i+1, j))
        # mark (i, j)
        v[i][j] = 1
        # 将访问结束的节点从Q中去除
        Q.remove((i, j))
    return c


# 从起点开始dfs
print(bfs(si, sj))

print(l)

```

## **4. 结果输出**

```txt
节点坐标：
4 6
59
节点访问顺序：
[(4, 6), (4, 5), (4, 4), (3, 4), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (6, 7), (6, 6), (6, 5), (6, 4), (6, 3), (6, 2), (5, 2), (4, 2), (3, 2), (2, 2), (1, 2), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10), (1, 10), (2, 10), (3, 10), (4, 10), (5, 10), (6, 10), (7, 10), (8, 10), (8, 9), (8, 8), (8, 7), (8, 6), (8, 5), (8, 4), (8, 3), (8, 2), (8, 1), (8, 0), (7, 0), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0)]


```
