# 数据结构复习 #
# 1.概论 #

## 1.1.引子 ##

## 1.2.数据结构 ##
### 1.2.1定义 ###
### 1.2.2抽象数据类型 ###
	数据结构：
			一、数据对象集；
			二、与数据集相关联的操作集。

## 1.2.算法（Algorithm） ##
### 1.2.1定义 ###
	算法：Algorithm
### 1.2.2.算法复杂度 ###
1. 空间复杂度S(n)：算法程序在执行时所占用的存储单元长度
1. 时间复杂度O(n)：算法程序在执行时所占用时所耗费的时间的长度。 		常见时间复杂度规模：O(1),O(n),O(n^2),O(n^3),O(lg N)

## 1.2.总结 ##
- 数据结构：包括数据对象集以及他们他们在计算机中的组织方式，即他们的逻辑结构和物理存储结构，同时还包括与数据对象集相关联的操作集，以及操作这些的最高效的算法。抽象数据类型时用来描述数据结构的重要工具。
- 算法：是解决问题步骤的有效集合，通常是用某种计算机语言进行伪代码描述。通常使用时间复杂度和空间复杂度来度量算法的优劣。使用渐进表示法分析算法复杂度的增长趋势。

----------

# 2.数据结构实现基础 #
## 2.1.引子 ##

## 2.2.数据存储基础 ##
### 2.2.1.数组 ###
	int N[10];
### 2.2.2.typedef关键字 ###
	typedef int Elemtype;
### 2.2.3.指针 ###
	int *p;
### 2.2.4.结构 ###
	1.结构体
	struct Student{
		int id;
		char name[10];
	};
	2.共用体
	union key{
		int k;
		char ch[2];
	};
### 2.2.5.链表 ###
	1.定义
	typedef struct Node *PrtTONode;
	struct Node{
		Elemtypde Data;
		PtrToNode Next;	
	};
	2.单链表常见操作
	（1）插入节点
		t->Next=p->Next;
		p->Next=t;
	（2）删除节点
		t=p->Next;
		p->next=t->Next;
		free(t);

## 2.3.流程控制基础 ##
### 2.3.1.分支控制 ###
	1.if-else语句
	2.switch语句
### 2.3.3.循环控制 ###
	1.for语句
	2.while语句
	3.do-while语句
	4.break和continue语句
	5.嵌套循环
### 2.3.4.函数和递归 ###
    N!
	int Factorial(int n){
		if(n==0)
			return 1;
		else
			return n*Factorial(n-1);
	}
	
	汉诺塔问题
	void move(int n, int start, int goal, int temp){
		if(n>=1){
			move(n-1, start, temp, goal);
			printf("move disk %d from %d to %d.\n", n, start, goal);
			move(n-1, temp, goal, start);
		}
		/*else 当n==0时不需要做任何事情*/
	}

----------

# 3.线性结构 #

## 3.1.引子 ##

## 3.2.线性表的定义和实现 ##

### 3.2.1.线性表的定义 ###
	线性表（Linear List）是由同一类型的数据元素构成的有序序列的线性结构。先行表中元素的个数称为线性表的长度；当一个线性表中没有元素时，称为空表；表的起始位置称为表头，表的结束位置成为表尾。

#### 抽象数据类型描述： ####
**类型名称：**线性表（List）

**数据对象集：**线性表是n（n>=0）个元素构成的有序序列(a1,a2,a3,...,an)，其中a1是表的第一个元素（表头），an是表的最后一个元素（表尾）；ai+1称为ai的直接后继，ai-1称为ai的直接前驱；直接前驱和直接后继反映了元素一对一的邻阶逻辑关系。

**操作集：**对于一个具体的线性表L，一个表示位序的整数i，一个元素x，线性表的具体操作主要有：

	（1）List makeEmpty（）：初始化一个空的线性表；
	（2）ElementType findKth（）：根据指定的位序，返回L中相应的元素ai；
	（3）Position find（List L，ElementType x）：已知x，返回线性表L中与x相同的第一个元素的位置；若不存在返回
	（4）bool insert（List L，ElementType x，int i）：在L的指定位序i前，插入一个元素x；成功返回true；失败，返回false；
	（5）boll delete（List L，int i）：从L中删除指定位序i的元素；成功返回true；失败返回false；
	（6）int length（List L）：返回线性表L的长度

### 3.2.2.线性表的顺序存储实现 ###
	typedef int ElementType;
	typedef struct LNOde * ptrToLNode;
	typedef int Position;
	struct LNOde{
		ElementType data[MAXSIZE];
		Position last;
	};
	typedef ptrToLNode List;
	/**
	* 1.初始化
	* 顺序表的初始化即构造一个空表。首先动态分配表结构所需的存储空间，然后哦将表中last指针置为-1，表示表中没有数据。
	* 
	* */
	List makeEmpty(){
		List L;
		L=(List)malloc(sizeof(struct LNOde));
		L.last=-1;
		return L;
	}

	/**
	* 2.查找
	* 顺序存储的线性表中，查找主要是指在线性表的查找与给定值x相等的数据元素。
	* 若存在，返回与x相等的元素的位置；
	* 否则，返回ERROR。
	* 时间复杂度：O(n)
	* */
	#define ERROR -1

	Position find(List L, ElementType x){
		Position i=0;
		while(i<L.last&&L->data[i]!=x)
			++i;
		if(i>L->last)
			return ERROR;               /*不存在，返回ERROR*/
		else 
			return i;                   /*返回该元素的下标*/
	}

	/**
	* 3.插入
	* 在线性表的第i个位序前插入一个新的元素x；当i=1时，代表插入到序列最前端；当i=n+1时，代表插入到序列最后。
	* 具体步骤：
	* （1）将ai~an顺序向后移动（移动次序为从an到ai），为新元素让出位置
	* （2）将x置入空出的位置
	* （3）修改last指针，使之仍指向最后一个元素
	* 时间复杂度为O(n)
	* */

	bool insert(List L, ElementType x, int i){
		Position j;
		if(L->last>=MAXSIZE-1){
			printf("表已满\n");
			return false;
		}
		if(i<1||i>L->last+2){
			printf("位序不合法\n");
			return false;
		}
		for(j=L->last;j>=i-1;--j)
			L->data[j+1]=L->data[j];
		L->data[i]=x;
		L->last++;
		return true;
	}

	/**
	* 4.删除
	* 线性表的删除是指将表中位序为i（1<=i<=n）的元素从线性表中去掉。
	* 具体步骤：
	* （1）将ai+1~an顺序向前移动，ai被覆盖；
	* （2）修改last指针，是指仍指向最后一个元素。
	* 时间复杂度为O(n)
	* */
	bool delete(List L, int i){
		Position j;
		if(i<1||i>L->last+1){
			printf("位序%d不存在元素\n", i);
			return false;
		}
		for(j=i+1;j<L->last;++j)
			L->data[j-1]=L->data[j];
		L->last--;
		return true;
	}

### 3.2.3.线性表的链式存储实现 ###
